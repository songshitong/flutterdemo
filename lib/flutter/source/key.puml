@startumlnote top of key{   key的应用时机     localkey 它应用于拥有相同父 Element 的小部件进行比较的情况,即有一个多子 Widget 中需要对它的子 widget 进行移动处理，        这时候你应该使用Localkey     globalkey 可以通过 GlobalKey 找到持有该GlobalKey的 Widget，State 和 Element   细分：     ValueKey   ValueKey(todo.task)        如果您有一个 Todo List 应用程序，它将会记录你需要完成的事情。我们假设每个 Todo 事情都各不相同，        而你想要对每个 Todo 进行滑动删除操作     ObjectKey        如果你有一个生日应用，它可以记录某个人的生日，并用列表显示出来，同样的还是需要有一个滑动删除操作。        我们知道人名可能会重复，这时候你无法保证给 Key 的值每次都会不同。但是，当人名和生日组合起来的 Object 将具有唯一性     UniqueKey         如果组合的 Object 都无法满足唯一性的时候，你想要确保每一个 Key 都具有唯一性。那么，你可以使用 UniqueKey。             它将会通过该对象生成一个具有唯一性的 hash 码。         不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey，失去了一致性。也就是说你的小部件还是会改变。（还不如不用😂）     PageStorageKey         当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。         这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态     GlobalKey         GlobalKey 能够跨 Widget 访问状态.在这里我们有一个 Switcher 小部件，它可以通过 changeState 改变它的状态         最好声明为static final         不然报错Currently the key is recreated every time _LoginState is rebuilt, which defeats it's purpose.               state重建时，globalkey也进行了重建，这违背了他的目的               https://github.com/flutter/flutter/issues/20042}abstract class key{  const factory Key(String value) = ValueKey<String>  const Key.empty()}'note right of key{'   [Key]是[Widget]，[Element]和[SemanticsNode]的标识符。'   如果新widget的key与与该element关联的当前widget的key相同，则widget将仅用于更新现有element'   在具有相同父级的[Element]中，键必须是唯一的'   [Key]的子类应该是[LocalKey]或[GlobalKey]的子类'}abstract class LocalKey{  const LocalKey() : super.empty()}'note right of LocalKey{'   不是[GlobalKey]的key(在整个应用程序中不必是惟一的)'   在具有相同父级的[Element]中，键必须是唯一的。'   [ValueKey <T>]等于另一个[ValueKey <T>]，如果且仅当它们的值为[operator ==]时'   相比之下，[GlobalKey]在整个应用程序中必须是唯一的。'}class ValueKey<T> {   final T value   bool operator ==(dynamic other)}'note right of ValueKey{'  使用特定类型的值来标识自身的key'  可以对此类进行子类化以创建值键，这些键值将不等于碰巧使用相同值的其他值键.如果子类是私有的,'    这会导致value key类型不能与来自其他源的键冲突, 这可能有用, for example, 如果key被用作与另一个widget提供的key相同范围内的后备''}abstract class GlobalKey<T extends State<StatefulWidget>> {  static final Map<GlobalKey, Element> _registry = <GlobalKey, Element>{}  Element get _currentElement => _registry[this]  BuildContext get currentContext => _currentElement;  Widget get currentWidget => _currentElement?.widget;  T get currentState}'note right of GlobalKey{'   整个应用程序中唯一的key 只使用于StatefulWidget和他的子类'   全局key唯一标识元素.全局key提供对与这些元素关联的其他对象的访问，例如[BuildContext]。对于[StatefulWidget]，全局键还提供对[State]的访问权限'   具有全局key的widget在从树中的一个位置移动到树中的另一个位置时重新显示其子树.为了重新显示其子树，widget必须到达树中的新位置，'       在同一动画帧中，它从树中的旧位置移除.'   全局key相对昂贵.如果您不需要上面列出的任何功能，请考虑使用[Key]，[ValueKey]，[ObjectKey]或[UniqueKey]。'   您不能在树中同时包含两个具有相同全局key的小部件。尝试这样做将在运行时断言。'   _registry 存储globalkey对应的element'}class GlobalObjectKey<T extends State<StatefulWidget>>{   final Object value}'note right of GlobalObjectKey{'   一个全局key，它从用作其值的对象中获取其标识'   用于将widget的标识绑定到用于生成该widget的对象的标识'   如果对象不是私有的，其中独立widget将在树的不同部分中重用与其[GlobalObjectKey]值相同的对象, 则可能发生冲突，'      导致全局性的关键冲突。要避免此问题，请创建一个私有[GlobalObjectKey]子类'      、、class _MyKey extends GlobalObjectKey {'      、、  const _MyKey(Object value) : super(value);'      、、  }'   由于key的[runtimeType]是其标识的一部分，因此即使它们具有相同的值，也可以防止与其他[GlobalObjectKey]的冲突。'}class ObjectKey{   final Object value}'note right of ObjectKey{'  从用作其值的对象获取其标识的key'  用于将widget的标识绑定到用于生成该widget的对象的标识。'}class UniqueKey{   String toString() => '[#${shortHash(this)}]'}'note right of UniqueKey{'  一个只与自身相等的关键。'}class PageStorageKey<T>{}key <|-- LocalKeykey <|-- GlobalKeyLocalKey <|-- ValueKeyLocalKey <|-- ObjectKeyLocalKey <|-- UniqueKeyGlobalKey <|-- GlobalObjectKeyValueKey  <|-- PageStorageKey@enduml