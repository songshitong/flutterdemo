@startuml

abstract class ScrollView{
  List<Widget> buildSlivers(BuildContext context)
  Widget buildViewport(BuildContext context,ViewportOffset offset,AxisDirection axisDirection,List<Widget> slivers)
  Widget build(BuildContext context)
}
'note right of ScrollView{
'  定义：滚动的widget
'  可滚动widget由三部分组成:
'    1 一个[Scrollable]widget，用于监听各种用户手势和实现滚动的交互设计
'    2 一个视口窗口widget，例如[Viewport]或[ShrinkWrappingViewport]通过仅显示滚动视图中widget的部分来实现滚动的视觉设计
'    3 一个或多个slivers，它们是可以组成创建各种滚动效果，例如列表，网格和扩展标题的widget
'  [ScrollView]通过创建[Scrollable]和视口并推迟到其子类来创建slivers来帮助编排这些片段
'  要控制滚动视图的初始滚动偏移，请提供设置了[ScrollController.initialScrollOffset]属性的[controller]
'
'  buildSlivers 构建要放置在视口内的窗口widget列表,子类应重写此方法以构建视口内部的slivers
'  buildSlivers 构建视口 子类可以重写此方法以更改视口的构建方式。如果[shrinkWrap]为true，则默认实现使用[ShrinkWrappingViewport]，否则使用常规[Viewport]
'
'  build 重写方法，将通过buildSlivers从子类获取的widget列表，通过buildSlivers构建的viewport和Scrollable这
'        三者组装到一起
'}

abstract class BoxScrollView{
  List<Widget> buildSlivers(BuildContext context)
  Widget buildChildLayout(BuildContext context)
}
'note left of BoxScrollView{
'  定义：使用单个子布局模型的[ScrollView]
'  buildSlivers: 重写ScrollView的方法，将从buildChildLayout获取的widget包裹在SliverPadding中，将其作为list返回
'  buildChildLayout :子类应重写此方法以构建布局模型 获取子类构建的widget
'}

class CustomScrollView{
   final List<Widget> slivers
   List<Widget> buildSlivers(BuildContext context)
}
'note right of CustomScrollView{
'  定义：使用slivers创建自定义滚动效果的[ScrollView]
'  [CustomScrollView]允许您直接提供[slivers]以创建各种滚动效果，例如列表，网格和扩展标题.例如，创建一个滚动视图，其中包含一个展开的app bar，
'  后跟一个列表和网格，使用三个slivers列表：[SliverAppBar]，[SliverList]，和[SliverGrid]
'  [Widget]中的[slivers]必须生成[RenderSliv​​er]对象，Viewport的createRenderObject为RenderViewport，而RenderViewport的父类RenderViewportBase
'      接受一个RenderSliver范型

'  要控制滚动视图的初始滚动偏移，请提供设置了[ScrollController.initialScrollOffset]属性的[controller]
'  [CustomScrollView]可以允许滚动状态更改时Talkback / VoiceOver通知用户。例如，在Android上公告可能被解读为“显示第1项至23项中的第10项”
'     生产这个公告，滚动视图需要三条信息：
'        1 第一个可见的子的索引index
'        2 孩子总数
'        3 可见孩子的总数
'  最后一个值可以由框架精确计算，但是前两个必须提供。大多数更高级别的可滚动widget自动提供此信息.例如，[ListView]为每个子widget自动提供
'    具有语义索引设并设置语义子级列表的长度
'  要确定可见索引，滚动视图需要一种方式关联每个可滚动item和一个语义索引index生成的语义。这个可以通过将子窗口小部件包装在[IndexedSemantics]中来完成
'  此语义索引不一定与可滚动widget的索引相同.因为某些小部件可能无法提供语义信息.考虑一个[new ListView.separated（）]：每个其他小部件都是
'  没有语义信息的分隔符.在这种情况下，只有奇数编号widget有一个语义索引（等于索引〜/ 2）.而且，此示例中的子项总数将是widgets数量的一半.
'    （[new ListView.separated（）]构造函数自动处理此问题.这仅用于此处作为示例
'  可见子项的总数可以通过构造函数参数`semanticChildCount`提供，这应该始终与[IndexedSemantics]中包含的小部件数相同
'
'  buildSlivers 重写方法，将slivers返回
'}

class ListView{
   Widget buildChildLayout(BuildContext context)
}

'note left of ListView{
'  buildChildLayout方法重写，如果子在滚动方向宽度itemExtent确定，返回SliverFixedExtentList，不确定则返回SliverList。这两者都是接受
'    SliverChildDelegate作为参数，至此将普通widget转换为sliver系列
'}

class GridView {
   Widget buildChildLayout(BuildContext context)
}
'note right of GridView{
'   重写buildChildLayout方法将SliverGridDelegate和SliverChildDelegate包装进SliverGrid返回
'}

class Scrollable{
  final bool excludeFromSemantics
  ScrollableState createState()
}

'note left of Scrollable{
'  定义：滚动的的widget
'  excludeFromSemantics  此[Scrollable]引入的滚动操作是否在语义树中公开,带溢出的文本字段通常是可滚动的，以确保用户可以到达输入文本的开头结尾.
'     但是，这些滚动操作通常不会暴露给语义层
'}

class ScrollableState{
   Widget build(BuildContext context)
}
'note left of ScrollableState{
'   build 重写方法，excludeFromSemantics为false，创建_ScrollSemantics，为true,创建_ScrollableScope。最后将结果通过ScrollBehavior的
'      buildViewportChrome创建widget
'}

class Viewport{
   final double anchor
   final ViewportOffset offset
   final Key center
   final double cacheExtent
   RenderViewport createRenderObject(BuildContext context)
}

'note right of Viewport{
'  定义： 内部更大的widget
'  [Viewport]是滚动机械的视觉主力。它根据其自身的维度和给定的[offset]显示一个children的子集。随着偏移量的变化，可以通过视口看到不同的孩子
'  [Viewport]主持一个双向的条子列表，锚定在位于零滚动偏移处的[center]sliver,中心小部件是根据[anchor]属性显示在视口中
'  子列表中早于[center]的sliver以反向[axisDirection]从[center]开始的逆序显示，例如，如果[axisDirection]是[AxisDirection.down]，
'   那么在center之前的第一个sliver位于[center]上方。子列表比[center]后来的条子,按顺序放在[axisDirection]中。例如，在前面的场景中，
'   [center]之后的第一个条子是位于[中心]下方
'  [视口]不能直接包含盒子类型的child。相反，使用[SliverList]，[SliverFixedExtentList]，[SliverGrid]或者 [SliverToBoxAdapter]
'
'  anchor 零滚动偏移的相对位置,例如，如果[anchor]为0.5且[axisDirection]为[AxisDirection.down]或[AxisDirection.up]，
'      则零滚动偏移量在视口中垂直居中.如果[anchor]为1.0，并且[axisDirection]为[AxisDirection.right]，则零滚动偏移为视口左边缘
'  offset 视口内的哪部分内容应该是可见的.[ViewportOffset.pixels]值确定视口用于选择要显示其内容的哪个部分的滚动偏移量.当用户滚动视口时，
'     此值会更改，这会更改显示的内容.通常是[ScrollPosition]
'  center [GrowthDirection.forward]增长方向的第一个孩子.[center]必须是ViewPort的child的key
'  cacheExtent 在RenderViewportBase中有解释，视口在可见区域之前和之后有一个区域，用于缓存在用户滚动时即将变为可见的项目。落在此缓存区域中
'     的项目即使它们在屏幕上不是（还）可见，也会被布局。[cacheExtent]描述缓存区域在视口前端之前和后端之后延伸的像素数。
'     视口将尝试覆盖children的总范围是 前端前的[cacheExtent]+主轴的范围+后端后的[cacheExtent]
'     缓存区域还用于在iOS上实现隐式可访问性滚动，当辅助功能焦点从可见的视口中的项移动到缓存区中的不可见项时，框架将使用（隐式）滚动操作
'        将该项目带入视图
'}
StatelessWidget <|-- ScrollView
ScrollView      <|-- BoxScrollView
ScrollView      <|-- CustomScrollView
ScrollView      <.. Scrollable
ScrollView      <.. Viewport

BoxScrollView   <|-- ListView
BoxScrollView   <|-- GridView

StatefulWidget  <|-- Scrollable
Scrollable      <.. ScrollableState
MultiChildRenderObjectWidget <|-- Viewport

@enduml